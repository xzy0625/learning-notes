### 关键

js的数字在内存中是用二进制存储的。JS中，使用双精度存放浮点数，来源 [IEEE 754](https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FIEEE%20754%2F3869922)

#### **浮点数存储数字如下：**

![image.png](https://csuxzy-images-1300770696.cos.ap-guangzhou.myqcloud.com/91cd3550b5694f2495498cbfb2c73010~tplv-k3u1fbpfcp-zoom-in-crop-mark:3780:0:0:0.awebp)

上图是64位的双精度浮点数，最高位是`符号位S（sign）`，中间的11位是`指数E（exponent）`，剩下的52位为`尾数（有效数字）M（mantissa）`

**浮点数科学计数法** 根据IEEE 754标准，任意一个浮点数的二进制都可以用如下公式进行表示：

V=(−1)s×2E×MV = (-1) ^ s \times 2 ^E \times MV=(−1)s×2E×M

- S为符号位：表示浮点数的正负（0代表正数，1代表负数）；
- E为指数位：存储指数，该数都会加上一个常数（偏移量），用来表示次方数（需要把二进制的数据转成十进制），长度是11位，取值范围是为0~2047。因为科学计数法中的指数是可以为负数，所以约定减去一个中间数（偏移量）1023，[0，1022] 表示为负，[1024，2047] 表示为正。；
- M为尾数位：表示有效位（尾数），超出的部分自动进1舍0，默认节省1位有效数字；

也就是说，我们存储的二进制的位数是有限的，当我们的十进制转化为二进制的时候，如果长度超过52位，那么就会截断，导致失去精度，从而产生这种问题

![image-20220802131613412](https://csuxzy-images-1300770696.cos.ap-guangzhou.myqcloud.com/image-20220802131613412.png)

可以看到，0.1转化之后是一个无穷的二进制，所以截断就导致失去精确度。

#### **那为什么 x=0.1 能得到 0.1？**

这是因为这个 0.1 并不是真正的0.1

标准中规定尾数f的固定长度是52位，再加上省略的一位，这53位是JS精度范围。它最大可以表示2^53(9007199254740992), 长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理

```scss
0.10000000000000000555.toPrecision(16)
// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1
// toPrecision() 方法以指定的精度返回该数值对象的字符串表示。

// 但来一个更高的精度，就非常的神奇：
0.1.toPrecision(21) = 0.100000000000000005551
```

![image-20220802132245665](https://csuxzy-images-1300770696.cos.ap-guangzhou.myqcloud.com/image-20220802132245665.png)

这个就是为什么0.1可以等于0.1的原因

### 那么什么时候会造成这种精度丢失呢

总结为：**精度损失可能出现在进制转化和[对阶运算](https://baike.baidu.com/item/%E5%AF%B9%E9%98%B6/10336161)过程中**

### 怎么处理呢

1. 改为整数相加减
2. 运用字符串模拟
3. 使用第三方库 -- 后续了解如何使用，具体第三方库在参考文献中有

### 参考文献

1. [重温js—— 数字的存储,js精度问题](https://juejin.cn/post/6992960127171035149)
2. [为什么0.1+0.2不等于0.3](https://juejin.cn/post/6844903680362151950)

